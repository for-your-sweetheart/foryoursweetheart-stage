<!DOCTYPE html>
<html><head><title>CodeMirror: C-like mode</title><meta charset="utf-8"><link rel="stylesheet" href="../../../../../../../wp-content/plugins/ajax-load-more/admin/codemirror/doc/docs.css"><link rel="stylesheet" href="../../../../../../../wp-content/plugins/ajax-load-more/admin/codemirror/lib/codemirror.css"><script src="../../../../../../../wp-content/plugins/ajax-load-more/admin/codemirror/lib/codemirror.js"></script><script src="../../../../../../../wp-content/plugins/ajax-load-more/admin/codemirror/addon/edit/matchbrackets.js"></script><link rel="stylesheet" href="../../../../../../../wp-content/plugins/ajax-load-more/admin/codemirror/addon/hint/show-hint.css"><script src="../../../../../../../wp-content/plugins/ajax-load-more/admin/codemirror/addon/hint/show-hint.js"></script><script src=""></script><style>.CodeMirror {border: 2px inset #dee;}</style></head><body><div id="nav">
  <a href=""><img id="logo" src="../../../../../../../wp-content/plugins/ajax-load-more/admin/codemirror/doc/logo.png"></a>

  <ul><li><a href="../../../../../../../wp-content/plugins/ajax-load-more/admin/codemirror/index.html">Home</a>
    </li><li><a href="../../../../../../../wp-content/plugins/ajax-load-more/admin/codemirror/doc/manual.html">Manual</a>
    </li><li><a href="">Code</a>
  </li></ul><ul><li><a href="../../../../../../../wp-content/plugins/ajax-load-more/admin/codemirror/mode/index.html">Language modes</a>
    </li><li><a class="active" href="">C-like</a>
  </li></ul></div>

<article><h2>C-like mode</h2>

<div><textarea id="c-code">
/* C demo code */

#include <zmq.h>
#include <pthread.h>
#include <semaphore.h>
#include <time.h>
#include <stdio.h>
#include <fcntl.h>
#include <malloc.h>

typedef struct {
  void* arg_socket;
  zmq_msg_t* arg_msg;
  char* arg_string;
  unsigned long arg_len;
  int arg_int, arg_command;

  int signal_fd;
  int pad;
  void* context;
  sem_t sem;
} acl_zmq_context;

#define p(X) (context->arg_##X)

void* zmq_thread(void* context_pointer) {
  acl_zmq_context* context = (acl_zmq_context*)context_pointer;
  char ok = 'K', err = 'X';
  int res;

  while (1) {
    while ((res = sem_wait(&context->sem)) == EINTR);
    if (res) {write(context->signal_fd, &err, 1); goto cleanup;}
    switch(p(command)) {
    case 0: goto cleanup;
    case 1: p(socket) = zmq_socket(context->context, p(int)); break;
    case 2: p(int) = zmq_close(p(socket)); break;
    case 3: p(int) = zmq_bind(p(socket), p(string)); break;
    case 4: p(int) = zmq_connect(p(socket), p(string)); break;
    case 5: p(int) = zmq_getsockopt(p(socket), p(int), (void*)p(string), &p(len)); break;
    case 6: p(int) = zmq_setsockopt(p(socket), p(int), (void*)p(string), p(len)); break;
    case 7: p(int) = zmq_send(p(socket), p(msg), p(int)); break;
    case 8: p(int) = zmq_recv(p(socket), p(msg), p(int)); break;
    case 9: p(int) = zmq_poll(p(socket), p(int), p(len)); break;
    }
    p(command) = errno;
    write(context->signal_fd, &ok, 1);
  }
 cleanup:
  close(context->signal_fd);
  free(context_pointer);
  return 0;
}

void* zmq_thread_init(void* zmq_context, int signal_fd) {
  acl_zmq_context* context = malloc(sizeof(acl_zmq_context));
  pthread_t thread;

  context->context = zmq_context;
  context->signal_fd = signal_fd;
  sem_init(&context->sem, 1, 0);
  pthread_create(&thread, 0, &zmq_thread, context);
  pthread_detach(thread);
  return context;
}
</malloc.h></fcntl.h></stdio.h></time.h></semaphore.h></pthread.h></zmq.h></textarea></div>

<h2>C++ example</h2>

<div><textarea id="cpp-code">
#include <iostream>
#include "mystuff/util.h"

namespace {
enum Enum {
  VAL1, VAL2, VAL3
};

char32_t unicode_string = U"\U0010FFFF";
string raw_string = R"delim(anything
you
want)delim";

int Helper(const MyType& param) {
  return 0;
}
} // namespace

class ForwardDec;

template <class t class v>
class Class : public BaseClass {
  const MyType<t v> member_;

 public:
  const MyType<t v>& Method() const {
    return member_;
  }

  void Method2(MyType<t v>* value);
}

template <class t class v>
void Class::Method2(MyType<t v>* value) {
  std::out > method();
  value->Method3(member_);
  member_ = value;
}
</t></class></t></t></t></class></iostream></textarea></div>

<h2>Java example</h2>

<div><textarea id="java-code">
import com.demo.util.MyType;
import com.demo.util.MyInterface;

public enum Enum {
  VAL1, VAL2, VAL3
}

public class Class<t v> implements MyInterface {
  public static final MyType<t v> member;
  
  private class InnerClass {
    public int zero() {
      return 0;
    }
  }

  @Override
  public MyType method() {
    return member;
  }

  public void method2(MyType<t v> value) {
    method();
    value.method3();
    member = value;
  }
}
</t></t></t></textarea></div>

    <script>
      var cEditor = CodeMirror.fromTextArea(document.getElementById("c-code"), {
        lineNumbers: true,
        matchBrackets: true,
        mode: "text/x-csrc"
      });
      var cppEditor = CodeMirror.fromTextArea(document.getElementById("cpp-code"), {
        lineNumbers: true,
        matchBrackets: true,
        mode: "text/x-c++src"
      });
      var javaEditor = CodeMirror.fromTextArea(document.getElementById("java-code"), {
        lineNumbers: true,
        matchBrackets: true,
        mode: "text/x-java"
      });
      var mac = CodeMirror.keyMap.default == CodeMirror.keyMap.macDefault;
      CodeMirror.keyMap.default[(mac ? "Cmd" : "Ctrl") + "-Space"] = "autocomplete";
    </script><p>Simple mode that tries to handle C-like languages as well as it
    can. Takes two configuration parameters: <code>keywords</code>, an
    object whose property names are the keywords in the language,
    and <code>useCPP</code>, which determines whether C preprocessor
    directives are recognized.</p>

    <p><strong>MIME types defined:</strong> <code>text/x-csrc</code>
    (C code), <code>text/x-c++src</code> (C++
    code), <code>text/x-java</code> (Java
    code), <code>text/x-csharp</code> (C#).</p>
</article></body></html>
